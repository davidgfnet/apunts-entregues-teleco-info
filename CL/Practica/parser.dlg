<<
/* parser.dlg -- DLG Description of scanner
 *
 * Generated from: cl.g
 *
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-2001
 * Purdue University Electrical Engineering
 * With AHPCRC, University of Minnesota
 * ANTLR Version 1.33MR33
 */

#define ANTLR_VERSION	13333
#include "pcctscfg.h"
#include "pccts_stdio.h"

#include <string>
#include <iostream>
#include <map>
#include <list>
#include <vector>
#include <fstream>

using namespace std;

#include <stdio.h>
#include <stdlib.h>
#include "ptype.hh"
#include "symtab.hh"
#include "codegest.hh"

/// struct to contain information about a token.
typedef struct {
  string kind;
  string text;
  int line;
} Attrib;

/// function called by the scanner when a new token is found
/// Predeclared here, definition below.
void zzcr_attr(Attrib *attr,int type,char *text);

/// Include AST node fields declaration
#include "myASTnode.hh"

/// Macro called by the parser when a new AST node is to be created
/// createASTnode function doing the actual job is defined below.
#define zzcr_ast(as,attr,tttype,textt) as=createASTnode(attr,tttype,textt);
AST* createASTnode(Attrib* attr, int ttype, char *textt);
#include "antlr.h"
#include "ast.h"
#include "tokens.h"
#include "dlgdef.h"
LOOKAHEAD

void
#ifdef __USE_PROTOS
zzerraction(void)
#else
zzerraction()
#endif
{
	(*zzerr)("invalid token");
	zzadvance();
	zzskip();
}
>>


%%START

@
	<<
		NLA = INPUTEND;
	>>

PROGRAM
	<<
		NLA = PROGRAM;
	>>

ENDPROGRAM
	<<
		NLA = ENDPROGRAM;
	>>

PROCEDURE
	<<
		NLA = PROCEDURE;
	>>

ENDPROCEDURE
	<<
		NLA = ENDPROCEDURE;
	>>

FUNCTION
	<<
		NLA = FUNCTION;
	>>

ENDFUNCTION
	<<
		NLA = ENDFUNCTION;
	>>

RETURN
	<<
		NLA = RETURN;
	>>

VARS
	<<
		NLA = VARS;
	>>

ENDVARS
	<<
		NLA = ENDVARS;
	>>

INT
	<<
		NLA = INT;
	>>

BOOL
	<<
		NLA = INT;
	>>

STRUCT
	<<
		NLA = STRUCT;
	>>

ENDSTRUCT
	<<
		NLA = ENDSTRUCT;
	>>

WRITELN
	<<
		NLA = WRITELN;
	>>

WRITE
	<<
		NLA = WRITE;
	>>

READ
	<<
		NLA = READ;
	>>

ARRAY
	<<
		NLA = ARRAY;
	>>

OF
	<<
		NLA = OF;
	>>

\+
	<<
		NLA = PLUS;
	>>

\-
	<<
		NLA = MINUS;
	>>

AND
	<<
		NLA = AND;
	>>

OR
	<<
		NLA = OR;
	>>

NOT
	<<
		NLA = NOT;
	>>

TRUE
	<<
		NLA = TRUECONST;
	>>

FALSE
	<<
		NLA = FALSECONST;
	>>

IF
	<<
		NLA = IF;
	>>

THEN
	<<
		NLA = THEN;
	>>

ENDIF
	<<
		NLA = ENDIF;
	>>

ELSE
	<<
		NLA = ELSE;
	>>

WHILE
	<<
		NLA = WHILE;
	>>

ENDWHILE
	<<
		NLA = ENDWHILE;
	>>

VAL
	<<
		NLA = PARVAL;
	>>

REF
	<<
		NLA = PARREF;
	>>

DO
	<<
		NLA = DO;
	>>

\*
	<<
		NLA = PRODUCT;
	>>

\/
	<<
		NLA = DIVISION;
	>>

=
	<<
		NLA = EQUAL;
	>>

<
	<<
		NLA = LESSTHAN;
	>>

>
	<<
		NLA = GREATERTHAN;
	>>

\(
	<<
		NLA = OPENPAR;
	>>

\)
	<<
		NLA = CLOSEPAR;
	>>

\[
	<<
		NLA = INDOPEN;
	>>

\]
	<<
		NLA = INDCLOSE;
	>>

:=
	<<
		NLA = ASIG;
	>>

.
	<<
		NLA = DOT;
	>>

,
	<<
		NLA = COMMA;
	>>

\"
	<<
		NLA = COMILLAS;
	>>

[\"]~[\"]*[\"]
	<<
		NLA = STRING;
	>>

[0-9]+
	<<
		NLA = INTCONST;
	>>

[a-zA-Z][a-zA-Z0-9]*
	<<
		NLA = IDENT;
	>>

//~[\n]*
	<<
		NLA = COMMENT;
    printf("%s",zzlextext); zzskip();   
	>>

[\ \t]+
	<<
		NLA = WHITESPACE;
    printf("%s",zzlextext); zzskip();   
	>>

\n
	<<
		NLA = NEWLINE;
    zzline++; printf("\n%3d: ", zzline); zzskip();   
	>>

~[]
	<<
		NLA = LEXICALERROR;
    printf("Lexical error: symbol '%s' ignored!\n", zzlextext);
    zzLexErrCount++;
    zzskip();   
	>>

%%
